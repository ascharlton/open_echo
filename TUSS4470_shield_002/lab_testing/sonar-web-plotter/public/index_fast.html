<!DOCTYPE HTML>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Open Echo Node.js Plot (Downsampled to 850 Samples)</title>
    <!-- Use Tailwind CSS for better styling and responsiveness --><script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Apply Inter font */
        body { font-family: 'Inter', sans-serif; }
        
        /* Chart container styling for the low-level Canvas implementation */
        .chart-container {
            width: 100%;
            /* ADJUSTED: Max width for the new 900px canvas to center neatly */
            max-width: 940px; 
            margin: auto;
            background-color: #000000;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            padding: 16px;
            padding-left: 0;
            padding-bottom: 0;
            
            /* REMOVED: Max-height and overflow to eliminate scrolling */
        }
        
        /* Ensure the Canvas element uses its native pixel size */
        #waterfall-canvas {
            /* ADJUSTED: New target size for 900x900 area (900px width includes 80px axis) */
            width: 900px; 
            height: 900px; 
            /* Renders the pixels sharply, crucial for heatmaps */
            image-rendering: crisp-edges; 
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex justify-center items-start min-h-screen p-4">
    <div class="container w-full max-w-7xl">
        <h1 class="text-3xl font-bold mb-4 text-center">Real-Time Sonar Waterfall Plot (Downsampled to 850 Samples)</h1>
        
        <div class="info-panel flex justify-around bg-gray-800 p-3 rounded-xl shadow-lg mb-6 text-sm flex-wrap space-y-2 sm:space-y-0">
            <div id="status" class="bg-blue-600 px-3 py-1 rounded-full">Status: Connecting...</div>
            <div id="depth-info" class="px-3 py-1">Depth: --- cm</div>
            <div id="temp-info" class="px-3 py-1">Temp: --- °C</div>
            <div id="vdrv-info" class="px-3 py-1">Vdrv: --- V</div>
            <div id="res-info" class="px-3 py-1">Resolution: 10 bits</div>
        </div>

        <div class="chart-container">
            <!-- ADJUSTED: Canvas resolution is 900 wide (820 plot + 80 axis) by 900 tall (850 samples + 50 axis) --><canvas id="waterfall-canvas" width="900" height="900"></canvas>
        </div>
        
        <div class="mt-6 text-center text-sm text-gray-400">
            <p>Data Range: 0 (Min) to 1023 (Max). Plotting <span id="num-samples-display">850</span> samples per frame (Downsampled).</p>
            <p>Display Max (Contrast): <span id="max-display">600</span> (Adjust with `setContrast(value)` in console)</p>
        </div>
    </div>

    <script>
        // --- CONSTANTS ---
        // ADJUSTED: X-axis resolution (number of history columns) is now 820
        const PLOT_WIDTH = 820; 
        
        // ADJUSTED: Y-axis display resolution (new height) is now 850 samples
        const DECIMATED_SAMPLES = 850; 
        const MAX_ADC_VALUE = 1023; // Maximum possible value from a 10-bit ADC
        
        // New constants for axis offsets
        const Y_AXIS_WIDTH = 80; // Space reserved on the left for Y-axis labels and title
        const X_AXIS_HEIGHT = 50; // Space reserved on the bottom for X-axis label and title
        
        // Physical Constants for Y-Axis Labeling (from Node.js script)
        const SPEED_OF_SOUND = 330; // m/s
        const SAMPLE_TIME = 13.2e-6; // s
        const SAMPLE_RESOLUTION = (SPEED_OF_SOUND * SAMPLE_TIME * 100) / 2; // ~0.2178 cm/sample

        let MAX_DISPLAY_VALUE = 300; // Default contrast setting
        const dataHistory = []; 
        
        // References for DOM elements
        const statusEl = document.getElementById('status');
        const depthEl = document.getElementById('depth-info');
        const tempEl = document.getElementById('temp-info');
        const vdrvEl = document.getElementById('vdrv-info');
        const maxDisplayEl = document.getElementById('max-display');
        document.getElementById('num-samples-display').textContent = DECIMATED_SAMPLES;

        // --- CANVAS SETUP ---
        const canvas = document.getElementById('waterfall-canvas');
        const ctx = canvas.getContext('2d');
        // Create an ImageData object once for reuse. It holds the raw pixel data.
        const imageData = ctx.createImageData(PLOT_WIDTH, DECIMATED_SAMPLES);
        const dataArray = imageData.data; // This is the 1D array of [R, G, B, A] values

        // --- HELPER: Decimate (Downsample) the data ---
        // This function is now actively downsampling from the original 1800 samples to 850.
        function downsampleSamples(samples, targetCount) {
            if (samples.length === targetCount) return samples;
            
            // Calculate step size to select which samples to include
            const step = samples.length / targetCount;
            const decimated = [];
            
            for (let i = 0; i < targetCount; i++) {
                // Find the nearest index in the original, larger array
                const index = Math.min(Math.round(i * step), samples.length - 1); 
                decimated.push(samples[index]);
            }
            return decimated;
        }
        
        // --- AXIS DRAWING ---
        function drawAxes(totalHistoryFrames) {
            // 1. Clear the entire canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 2. Draw the waterfall plot image data (the pixels)
            // It starts at Y_AXIS_WIDTH (80px) and 0 top offset.
            ctx.putImageData(imageData, Y_AXIS_WIDTH, 10);

            // --- Styling for all labels ---
            ctx.fillStyle = '#ffffff'; // White text
            ctx.strokeStyle = '#6b7280'; // Gray lines
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // --- Y-AXIS (Depth/Distance) ---

            // 1. Title (Rotated)
            ctx.save();
            // Translate to the center of the Y-axis reserved area, halfway down the plot
            ctx.translate(Y_AXIS_WIDTH / 2, DECIMATED_SAMPLES / 2);
            ctx.rotate(-Math.PI / 2); // Rotate 90 degrees counter-clockwise
            ctx.font = '18px Inter';
            ctx.fillText('Distance (cm)', 0, 0);
            ctx.restore();

            // 2. Labels and Ticks
            // Using 5 labels for better spacing on the 850px tall plot
            const numLabels = 4; 
            for (let i = 0; i <= numLabels; i++) {
                const fraction = i / numLabels;
                //console.log(fraction);
                
                // Pixel position on the canvas (from 0 to 850). 
                const yPos = DECIMATED_SAMPLES * fraction; 
                
                // Real-world value (Distance in cm)
                // Assuming original sample count was 1800 for the total distance calculation
                const originalTotalSamples = 1800; 
                const sampleIndex = Math.round(originalTotalSamples * fraction); 
                const distanceCm = sampleIndex * SAMPLE_RESOLUTION;

                // Draw tick mark next to the plot area
                ctx.beginPath();
                ctx.moveTo(Y_AXIS_WIDTH - 5, yPos);
                ctx.lineTo(Y_AXIS_WIDTH, yPos);
                ctx.strokeStyle = '#ffffff'; 
                ctx.stroke();
                
                // Draw label text
                ctx.textAlign = 'right';
                ctx.font = '12px Inter';
                // Ensure label doesn't overlap the tick line
                ctx.fillText(`${distanceCm.toFixed(1)}`, Y_AXIS_WIDTH - 8, yPos);
            }
            
            // --- X-AXIS (Time/History) ---

            // 1. Title
            ctx.textAlign = 'center';
            ctx.font = '18px Inter';
            // Positioned below the plot area
            ctx.fillText('History (Frames)', Y_AXIS_WIDTH + PLOT_WIDTH / 2, DECIMATED_SAMPLES + X_AXIS_HEIGHT / 2 + 5);
            
            // 2. Labels (Mark every 100 frames)
            const numXTicks = 8; // Ticks across the new 820 width
            for (let i = 0; i <= numXTicks; i++) {
                const frameNumber = i * (PLOT_WIDTH / numXTicks); 
                
                // X position on the canvas (Offset + Frame position)
                const xPos = Y_AXIS_WIDTH + frameNumber;

                // Draw tick mark below the plot area
                ctx.beginPath();
                ctx.moveTo(xPos, DECIMATED_SAMPLES);
                ctx.lineTo(xPos, DECIMATED_SAMPLES + 5);
                ctx.strokeStyle = '#ffffff'; 
                ctx.stroke();

                // Draw label text
                ctx.textAlign = 'center';
                ctx.font = '12px Inter';
                
                // Show relative frame number, or total history count if maxed out
                let labelText = totalHistoryFrames < PLOT_WIDTH ? 
                                (frameNumber > totalHistoryFrames ? '' : `${frameNumber}`) : 
                                `${frameNumber}`;

                ctx.fillText(labelText, xPos, DECIMATED_SAMPLES + 15);
            }
        }


        // --- OPTIMIZED RENDERING LOOP (using putImageData) ---
        function renderWaterfall() {
            const historyLength = dataHistory.length;
            
            // Loop through every pixel (x, y) on the canvas
            for (let x = 0; x < PLOT_WIDTH; x++) {
                const samples = dataHistory[x] || [];
                
                // If we don't have enough history, draw black
                if (x >= historyLength) {
                    for (let y = 0; y < DECIMATED_SAMPLES; y++) {
                         // Index calculation for the 1D dataArray: (y * width + x) * 4
                        const pixelIndex = (y * PLOT_WIDTH + x) * 4;
                        dataArray[pixelIndex] = 0;   // R
                        dataArray[pixelIndex + 1] = 0; // G
                        dataArray[pixelIndex + 2] = 0; // B
                        dataArray[pixelIndex + 3] = 255; // A (full opacity)
                    }
                    continue;
                }

                // Iterate through the vertical samples (Y-axis)
                for (let y = 0; y < DECIMATED_SAMPLES; y++) {
                    const rawValue = samples[y] || 0;
                    
                    // SCALING: Map rawValue to 0-1 ratio based on MAX_DISPLAY_VALUE
                    const ratio = Math.min(rawValue / MAX_DISPLAY_VALUE, 1); 
                    const intensity = Math.round(255 * ratio); 
                    
                    // Index calculation for the 1D dataArray: (y * width + x) * 4
                    const pixelIndex = (y * PLOT_WIDTH + x) * 4;

                    // *** BRIGHT YELLOW-ORANGE GRADIENT FOR VISIBILITY ***
                    // Over-scale R and G slightly to ensure that even values near MAX_DISPLAY_VALUE are bright yellow/white.
                    const r = Math.min(255, Math.round(intensity * 1.5));
                    const g = Math.min(255, Math.round(intensity * 1.5));
                    const b = Math.min(255, Math.round(intensity * 0.1)); 
                    
                    dataArray[pixelIndex] = r;      // Red component (Strong)
                    dataArray[pixelIndex + 1] = g;  // Green component (Strong, makes it yellow/orange)
                    dataArray[pixelIndex + 2] = b;  // Blue component (Kept low for warm tone)
                    dataArray[pixelIndex + 3] = 255;    // Alpha component (Opaque)
                }
            }

            // Draw the pixels onto the ImageData object and then draw the axes on the canvas
            drawAxes(historyLength); 

            // Request the next frame to keep the visualization running smoothly
            requestAnimationFrame(renderWaterfall);
        }

        // Start the continuous rendering loop
        renderWaterfall();

        // Optional: Allow the user to adjust the MAX_DISPLAY_VALUE (contrast) in the console
        window.setContrast = (newMax) => {
            if (newMax > 0 && newMax <= MAX_ADC_VALUE) {
                MAX_DISPLAY_VALUE = newMax;
                maxDisplayEl.textContent = newMax;
                console.log(`Contrast set: MAX_DISPLAY_VALUE = ${newMax}`);
            } else {
                console.error('Invalid contrast value. Must be between 1 and ${MAX_ADC_VALUE}.');
            }
        };


        // --- WebSocket Client ---
        const ws = new WebSocket(`ws://${location.hostname}:3000`);

        ws.onopen = () => {
            statusEl.className = 'bg-green-600 px-3 py-1 rounded-full';
            statusEl.textContent = 'Status: Connected';
            console.log('WebSocket connected.');
        };

        // When data arrives, we *only* process it and update the history. 
        // Rendering is handled by the requestAnimationFrame loop.
        ws.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                
                // 1. Update Info Panel
                depthEl.textContent = `Depth: ${data.depth} cm`;
                tempEl.textContent = `Temp: ${data.temperature} °C`;
                vdrvEl.textContent = `Vdrv: ${data.driveVoltage} V`;

                // 2. Downsample and Add new sample column to history
                // The data is now actively downsampled from the original 1800 samples to 850
                const decimatedSamples = downsampleSamples(data.samples, DECIMATED_SAMPLES);
                dataHistory.push(decimatedSamples);
                
                if (dataHistory.length > PLOT_WIDTH) {
                    // Shift the history to the left (removing the oldest column)
                    dataHistory.shift(); 
                }

                // 3. Update status
                if (statusEl.textContent === 'Status: Connecting...') {
                    statusEl.className = 'bg-blue-600 px-3 py-1 rounded-full';
                    statusEl.textContent = 'Status: Streaming Data';
                }

            } catch (e) {
                console.error('Client-side data processing failed:', e);
                statusEl.className = 'bg-red-600 px-3 py-1 rounded-full';
                statusEl.textContent = 'Status: Processing Error';
            }
        };

        ws.onclose = () => {
            statusEl.className = 'bg-gray-600 px-3 py-1 rounded-full';
            statusEl.textContent = 'Status: Disconnected';
        }
        
    </script>
</body>
</html>
